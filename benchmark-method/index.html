<!DOCTYPE html><html lang="ko"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>My SSD Benchmark Method - Memoria</title><meta name="description" content="Change log 6.25 - 어색한 문맥 수정, Reference 목록 추가 6.26 -&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://freshflash4096.github.io/benchmark-method/"><link rel="alternate" type="application/atom+xml" href="https://freshflash4096.github.io/feed.xml" title="Memoria - RSS"><link rel="alternate" type="application/json" href="https://freshflash4096.github.io/feed.json" title="Memoria - JSON"><link rel="shortcut icon" href="https://freshflash4096.github.io/media/website/Piskel.png" type="image/x-icon"><link rel="preload" href="https://freshflash4096.github.io/assets/dynamic/fonts/redhatdisplay/redhatdisplay.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://freshflash4096.github.io/assets/css/style.css?v=aece06c258dbfa8a0eaa3fa13993ea2f"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://freshflash4096.github.io/benchmark-method/"},"headline":"My SSD Benchmark Method","datePublished":"2025-06-22T02:20+09:00","dateModified":"2025-06-26T22:16+09:00","description":"Change log 6.25 - 어색한 문맥 수정, Reference 목록 추가 6.26 -&hellip;","author":{"@type":"Person","name":"Huie","url":"https://freshflash4096.github.io/authors/huie/"},"publisher":{"@type":"Organization","name":"Huie"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript><script defer="defer" src="https://tracker.megumi.moe/script.js" data-website-id="0b8c82bc-4877-4328-909b-54f7fbd85839"></script><meta name="naver-site-verification" content="f6d909f0d4d248d8e86d3eeb9ed2a68f1127024a"><meta name="google-site-verification" content="okm0s3kwgizr9te6gTQeSGvgFXalwMXsZ6iBVEnQFak"></head><body class="post-template"><div class="container"><div class="left-bar"><div class="left-bar__inner"><header class="header"><a class="logo" href="https://freshflash4096.github.io/">Memoria</a><nav class="navbar"><button class="navbar__toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle__box"><span class="navbar__toggle__inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://freshflash4096.github.io/about-this-blog/" target="_self" aria-label="Notice"><span>Notice</span></a></li><li><a href="https://freshflash4096.github.io/tags/homelab/" target="_self" aria-label="HomeLab"><span>HomeLab</span></a></li><li><a href="https://freshflash4096.github.io/tags/archive/" target="_self" aria-label="Archive"><span>Archive</span></a></li></ul></nav><a class="logo logo--atbottom" href="https://freshflash4096.github.io/">Memoria</a></header></div></div><main class="main post"><article class="content"><div class="content__meta content__meta--attop"><div class="content__meta--attop__inner"><div class="content__maintag"><svg width="20" height="20" aria-hidden="true" focusable="false"><use xlink:href="https://freshflash4096.github.io/assets/svg/svg-map.svg#tag"/></svg> Published in <a href="https://freshflash4096.github.io/tags/benchmark/" class="metadata__maintag">Benchmark</a></div></div></div><div class="main__inner"><div class="content__meta"><div class="content__date"><time datetime="2025-06-22T02:20">6월 22, 2025</time></div></div><header class="content__header"><h1 class="content__title">My SSD Benchmark Method</h1></header><div class="content__entry"><blockquote><p>Change log</p><p>6.25 - 어색한 문맥 수정, Reference 목록 추가</p><p>6.26 - Windows기반 벤치마크 상세옵션 명시</p></blockquote><p> </p><p>국내외를 불문하고 컴덕들을 위한 커뮤니티가 존재합니다. 그리고 커뮤니티에선 새로운 컴퓨터 부품에 대한 벤치마크가 여럿 올라옵니다.</p><p>예시를 들자면, 국내에선 쿨엔조이, 퀘이사존, 조드가 있으며, 해외에선 TechPowerUp, Tom's Hardware 등이 유명하죠. </p><p>전 상술한 국내 커뮤니티 어느 곳에서도 활동하지 않지만, 최근에 제 SSD 벤치마크를 공유하고자 일부에는 계정을 만들었습니다. </p><hr><p>잡담은 그만하고 본론으로 넘어가겠습니다. 벤치마크 대상이 되는 부품 중에선 저장장치가 당연히 존재하며, SSD의 보급이 이루어진 현재는 소비자에게 가장 흔한 저장장치가 SSD라고 해도 과언이 아닐까합니다.</p><p>흔히 사용하는 벤치마크 도구로는 CrystalDiskMark, ATTO Disk Benchmark, 국내 한정으로 나래온 더티테스트가 있습니다. 해당 도구들은 사용하기 굉장히 편리하게 설계되어 버튼 한 번만 누른다면 결과값을 바로 출력해주죠. 하지만 결과값의 신뢰성에 대해선 재고해봐야 할 문제입니다.</p><figure class="post__image"><img loading="lazy" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);" src="https://freshflash4096.github.io/media/posts/31/seukeurinsyas-2025-06-21-ohu-11.10.42.png" alt="" width="2290" height="1328"><figcaption>SSD Performace Change</figcaption></figure><p>SSD의 성능은 변화합니다. 가장 처음의 FOB(Fresh Out of Box)상태에서 Transition 단계를 거쳐 안정적인 Steady State로 향하죠. NAND기반의 모든 저장장치는 이와 같은 단계를 따릅니다.</p><p>eSSD(enterprise SSD)는 일반적으로 데이터시트의 값들도 Steady State가 기준인 경우가 대부분이기에 Pre-Conditioning을 거친 후, Steady State의 성능을 측정하는 것이 옳습니다. 하지만 cSSD(consumer SSD)는 FOB의 성능을 데이터시트에 명시해둡니다.</p><p>cSSD의 판매대상인 일반 소비자가 진정으로 Steady State를 경험할 일이 많은가에 대해서도 고민해봐야합니다. 하지만, 사람들이 사용하는 SSD의 상태는 FOB와 다른 것이 명백합니다.</p><p>거기에 더해, 현대 cSSD에는 대부분 SLC 캐시라는 메커니즘이 포함되어 있습니다. 초기형 SLC캐시는 단순히 고정된 용량이었지만, 최신형에선 전체 공간을 시뮬레이션하는 경우도 있는가하면, 일부 공간만을 시뮬레이션 하는 경우도 있어 성능 측정이 굉장히 복잡해졌습니다.</p><p>많은 고민이 있었습니다. 한창 SSD에 관심을 가지기 시작했던 <a href="https://huie.tistory.com/47">22년도</a>부터 이러한 고민을 했던 것 같네요.</p><p>여러 번의 시행착오와 실험을 거쳐 저는 아래와 같은 저만의 벤치마크 방법을 수립했습니다. 급하게 진행해야했던 Intel Optane SSD 905P 960GB를 예시로 들어 기술하겠습니다.</p><div class="post__toc"><h3>목차</h3><ul><li><a href="#mcetoc_1iuejnn4l47m">cSSD Benchmarking Method</a><ul><li><a href="#mcetoc_1iuejmtca479">Pre-Conditioning</a></li><li><a href="#mcetoc_1iuejmtca47a">CrystalDiskMark 9.x.x</a></li><li><a href="#mcetoc_1iuejmtca47b">3DMark Storage Benchmark</a></li><li><a href="#mcetoc_1iuejqi41492">SPECworkstation 4.0.0</a></li><li><a href="#mcetoc_1iuejqi41494">Fill Drive</a></li><li><a href="#mcetoc_1iuejqi41495">Sync Performance</a></li><li><a href="#mcetoc_1iuejmtca47g">Low QD Performance by RW Ratio </a></li><li><a href="#mcetoc_1iujf14onc8">Percentile Latency</a></li><li><a href="#mcetoc_1iuejmtca47i">Tail Latency</a></li></ul></li><li><a href="#mcetoc_1iueju0sm49b">How about eSSD Benchmarking?</a></li><li><a href="#mcetoc_1iuek3eau49h">Benchmark Flow</a></li><li><a href="#mcetoc_1iuek3eau49h">Test Platform</a><ul><li><a href="#mcetoc_1iuek40fa49k">Hardware</a></li><li><a href="#mcetoc_1iuek4g3749n">Software</a></li><li><a href="#mcetoc_1iujejkk8bn">Future Improvements</a></li></ul></li><li><a href="#mcetoc_1iuel76km4a0">Closing</a></li><li><a href="#mcetoc_1iuel7q734a3">Reference</a></li></ul></div><hr><h2 id="mcetoc_1iuejnn4l47m">cSSD Benchmarking Method</h2><h3 id="mcetoc_1iuejmtca479">Pre-Conditioning</h3><p>윗 문단에서 언급했지만, SSD에서 FOB 성능은 유저가 실질적으로 체감하기 힘든 부분입니다. 그렇다면 SNIA SSS-PTS에 언급된대로의 Pre-Conditioning을 진행해 Steady State를 측정하는 것이 좋을까요? cSSD에 대해서는 조심스레 무조건 긍정하긴 어려울 것 같다는 의견을 제시합니다. </p><p>일반 소비자의 워크로드는 몇 가지 특징을 따르는데, 그중 눈여겨 볼 부분이 있습니다. 바로 <strong>유휴시간이 상당</strong>하다는 것과 <strong>일부영역에만 활발하게 엑세스</strong>한다는 것입니다. 저는 제 cSSD 벤치마크의 Pre-Conditioning 단계를 아래와 같이 정의했습니다.</p><ol><li>장치를 Purge</li><li>LBA의 200%를 128kiB SEQ Write</li><li>LBA의 앞에서 8GiB를 4kiB RND Write</li><li>사용 중인 공간이 75%가 되도록 LBA 기준으로 뒤에서 25%를 Trim</li></ol><p>그럼, 사용하는 도구로 넘어가겠습니다.</p><h3 id="mcetoc_1iuejmtca47a">CrystalDiskMark 9.x.x</h3><div class="gallery-wrapper"><div class="gallery" data-is-empty="false" data-translation="이미지 추가" data-columns="3"><figure class="gallery__item"><a href="https://freshflash4096.github.io/media/posts/31/gallery/seukeurinsyas-2025-06-21-235614.png" data-size="1002x547"><img loading="lazy" src="https://freshflash4096.github.io/media/posts/31/gallery/seukeurinsyas-2025-06-21-235614-thumbnail.png" alt="" width="768" height="419"></a><figcaption>905P 960GB - Default / FOB</figcaption></figure><figure class="gallery__item"><a href="https://freshflash4096.github.io/media/posts/31/gallery/seukeurinsyas-2025-06-22-001645.png" data-size="1002x547"><img loading="lazy" src="https://freshflash4096.github.io/media/posts/31/gallery/seukeurinsyas-2025-06-22-001645-thumbnail.png" alt="" width="768" height="419"></a><figcaption>905P 960GB - NVMe / FOB</figcaption></figure></div></div><div class="gallery-wrapper"><div class="gallery" data-is-empty="false" data-translation="이미지 추가" data-columns="3"><figure class="gallery__item"><a href="https://freshflash4096.github.io/media/posts/31/gallery/seukeurinsyas-2025-06-22-012113.png" data-size="1002x547"><img loading="lazy" src="https://freshflash4096.github.io/media/posts/31/gallery/seukeurinsyas-2025-06-22-012113-thumbnail.png" alt="" width="768" height="419"></a><figcaption>905P 960GB - Default</figcaption></figure><figure class="gallery__item"><a href="https://freshflash4096.github.io/media/posts/31/gallery/seukeurinsyas-2025-06-22-012450.png" data-size="1002x547"><img loading="lazy" src="https://freshflash4096.github.io/media/posts/31/gallery/seukeurinsyas-2025-06-22-012450-thumbnail.png" alt="" width="768" height="419"></a><figcaption>905P 960GB - NVMe</figcaption></figure></div></div><p>가장 대중적인 도구인 CrystalDiskMark. 백엔드의 diskspd를 바로 사용하는 것도 고민했지만, 미리 설정된 프로필을 사용해 사람들에게 쉽게 읽혀지는 것이 목적입니다. FOB상태와 Pre-Conditioning을 끝낸 상태에 대해 기본 프로필과 NVMe 프로필에서 측정합니다. <strong>이후로 제 벤치마크는 별도의 언급이 없다면 FOB상태의 성능은 측정하지 않습니다.</strong></p><h3 id="mcetoc_1iuejmtca47b">3DMark Storage Benchmark</h3><figure class="post__image"><img loading="lazy" src="https://freshflash4096.github.io/media/posts/31/seukeurinsyas-2025-06-22-020535.png" alt="" width="1386" height="873"><figcaption>3DMark Storage Benchmark - Capture</figcaption></figure><figure class="post__image"><img loading="lazy" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);" src="https://freshflash4096.github.io/media/posts/31/Figure_1-4.png" alt="" width="1000" height="200"><figcaption>3DMark Storage Benchmark - Score</figcaption></figure><p>게임 성능 벤치마크로 유명한 3DMark의 DLC옵션인 3DMark Storage Benchmark입니다. 이 DLC만을 위해서 그래픽카드도 없는 제가 3DMark를 직접 구매했습니다. CDM과 더불어 다른 리뷰에서도 많이 보이는 벤치마크 도구이기에 자세한 설명은 생략하겠습니다.</p><h3 id="mcetoc_1iuejqi41492">SPECworkstation 4.0.0</h3><figure class="post__image"><img loading="lazy" src="https://freshflash4096.github.io/media/posts/31/Figure_1-3.png" alt="" width="1000" height="200"><figcaption>SPECworkstation - SPEC Ratio</figcaption></figure><p>SPECworkstation은 SPEC(Standard Performance Evaluation Corporation)에서 워크스테이션의 성능 지표를 측정하기 위해 만들어진 벤치마크 도구이며, WPCstorage 워크로드는 스토리지의 성능을 측정합니다. 결과는 SPEC Ratio라는 기준으로 출력되며, <a href="https://github.com/SPEC-GWPG-Dev/SPECgwpg-Docs/blob/main/SPECworkstation4/SPECworkstation4-User-Guide.md#reference-machine">Reference Machine</a>의 성능에 대한 비율로 측정됩니다.</p><h3 id="mcetoc_1iuejqi41494">Fill Drive</h3><figure class="post__image"><img loading="lazy" src="https://freshflash4096.github.io/media/posts/31/Figure_1-2.png" alt="" width="1000" height="500"><figcaption>Fill Drive - BW/TGBW</figcaption></figure><figure class="post__image"><img loading="lazy" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);" src="https://freshflash4096.github.io/media/posts/31/Figure_1-6.png" alt="" width="1000" height="500"><figcaption>Fill Drive - BW/Time</figcaption></figure><figure class="post__image"><img loading="lazy" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);" src="https://freshflash4096.github.io/media/posts/31/Figure_1-7.png" alt="" width="1000" height="500"><figcaption>Fill Drive - LAT/Time</figcaption></figure><p>많은 곳에서 볼 수 있는 합성 벤치마크입니다. 국내에서는 나래온 더티테스트를 통해 이러한 벤치마크를 진행하는데, 개인적으로 나래온 더티테스트는 X축이 용량 단위이며, 기록 단위도 용량의 0.1% 단위라는 것이 꽤 큰 단점이라고 생각해 직접 진행하기로 했습니다.</p><p>100ms단위로 측정하며, 워크로드는 SEQ 128kiB QD256입니다. 해당 벤치마크는 목적상 이례적으로 FOB상태에서 진행해 용량의 100%를 채우고 휴식을 부여합니다. 그리고 한 번 더 용량의 100%에 해당하는 쓰기를 가합니다. cSSD에선 이를 통해 SLC캐시의 형태를 대략적으로 파악할 수 있으리라 기대됩니다.</p><p>그래프는 6가지가 제시됩니다. 미리 제시된 첫 번째 그래프는 직관적인 이해를 위해 제시했지만, 최신 cSSD처럼 SLC캐시를 적용해 시간이 지남에 따라 변화하는 성능이라면 해상도 분포가 다른 것이 상당한 단점입니다. 두 번째는 평균값에 대한 수평선을 추가했으며, 세 번째는 지연시간을 통해 안정적인 정도를 파악할 수 있습니다. </p><p>이외에 추가될 그래프는 최대, 최소 SLC 캐시 사이즈와 평균 대역폭을 순서대로 정렬한 그래프입니다. 양식은 아래의 Sync Performance 파트에 사용된 막대 그래프와 같습니다.</p><h3 id="mcetoc_1iuejqi41495">Sync Performance</h3><figure class="post__image"><img loading="lazy" src="https://freshflash4096.github.io/media/posts/31/Figure_1.png" alt="" width="1000" height="200"><figcaption>Sync Performance - SEQ Write BW</figcaption></figure><figure class="post__image"><img loading="lazy" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);" src="https://freshflash4096.github.io/media/posts/31/Figure_1-10.png" alt="" width="1000" height="200"><figcaption>Sync Performance - SEQ Write LAT</figcaption></figure><figure class="post__image"><img loading="lazy" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);" src="https://freshflash4096.github.io/media/posts/31/Figure_1-9.png" alt="" width="1000" height="200"><figcaption>Sync Performance - RND Write BW</figcaption></figure><figure class="post__image"><img loading="lazy" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);" src="https://freshflash4096.github.io/media/posts/31/Figure_1-8.png" alt="" width="1000" height="200"><figcaption>Sync Performance - RND Write LAT</figcaption></figure><p>동기 쓰기, fsync()의 성능을 확인합니다. 일반적으로 경험하는 워크로드는 비동기 쓰기인 경우가 많습니다. 하지만 Homelab에서 ZFS나 Ceph 등을 사용하는 경우, 동기 쓰기 워크로드가 발생하기도 합니다.</p><p>cSSD에서 동기 쓰기는 HW PLP(Power Less Protection)이 구현되지 않아 펌웨어의 차이로 인해 일반적으로 생각하는 쓰기 성능과 차이가 심하게 납니다. 일반적으로 찾아보기 힘든 정보인 부분도 있어 해당 벤치마크를 채용했습니다.</p><p>SEQ 성능은 128kiB QD1으로 1GiB를 작성하며, Pre-Conditioning 단계에서 순차로 작성된 영역에만 접근합니다. LBA 기준으로 8GiB ~ 총 용량의 75% 지점입니다.</p><p>RND 성능은 4kiB QD1으로 1GiB를 작성하며, Pre-Conditioning 단계에서 랜덤으로 작성된 영역에만 <span style="text-decoration: underline;">완전히 랜덤</span>으로 접근합니다. LBA 기준으로 0GiB에서 8GiB 지점입니다. </p><h3 id="mcetoc_1iuejmtca47g">Low QD Performance by RW Ratio </h3><figure class="post__image"><img loading="lazy" src="https://freshflash4096.github.io/media/posts/31/Figure_1-11.png" alt="" width="1200" height="600"><figcaption>SEQ Performance on RW Ratio</figcaption></figure><figure class="post__image"><img loading="lazy" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);" src="https://freshflash4096.github.io/media/posts/31/Figure_1-12.png" alt="" width="1200" height="600"><figcaption>RND Performance on RW Ratio</figcaption></figure><figure class="post__image"><img loading="lazy" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);" src="https://freshflash4096.github.io/media/posts/31/Figure_1-14.png" alt="" width="1200" height="600"><figcaption>SEQ Performance on RW Ratio - Weighted</figcaption></figure><figure class="post__image"><img loading="lazy" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);" src="https://freshflash4096.github.io/media/posts/31/Figure_1-13.png" alt="" width="1200" height="600"><figcaption>RND Performance on RW Ratio - Weighted</figcaption></figure><p>cSSD의 스펙시트는 SEQ RW, RND RW로 이루어진 4-corners performance만 제시합니다. 하지만 일반적인 SSD는 읽쓰기 작업이 혼합되어 있을 때 성능이 하락하며, 100% 읽기 또는 100% 쓰기의 작업이 발생하는 것은 드뭅니다. 따라서 읽기 비율을 10% 단위로 변경하며 성능을 측정합니다.</p><p>SEQ은 128kiB QD1, QD2, QD4로 진행하며 각 128MiB *3의 작업을 수행하고, RND도 4kiB QD1, QD2, QD4로 진행하며 각 4MiB *160의 작업을 수행합니다. 앞의 Sync 성능 측정과 동일하게 SEQ과 RND은 Pre-Conditioning이 진행된 각 영역에만 접근합니다.</p><p>다른 SSD과 비교는 QD1 70%, QD2 20%, QD4 10%로 가중치를 부여한 그래프를 통해 진행합니다. 여기에 더해, 이 벤치마크를 진행하며 아래의 Percentile Latency, Tail Latency 분석에서도 활용되는 정보를 추출합니다.</p><h3 id="mcetoc_1iujf14onc8">Percentile Latency</h3><figure class="post__image"><img loading="lazy" src="https://freshflash4096.github.io/media/posts/31/Figure_1-15.png" alt="" width="1000" height="600"><figcaption>RND Read - Percentile/LAT</figcaption></figure><figure class="post__image"><img loading="lazy" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);" src="https://freshflash4096.github.io/media/posts/31/Figure_1-18.png" alt="" width="1000" height="600"><figcaption>RND Write - Percentile/LAT</figcaption></figure><p>기본적으로 cSSD의 스펙시트에는 지연시간을 잘 나타내지 않습니다. 하지만 실질적으로 사용자가 체감하게 되는 것은 프로그램들을 실행시킨것이나 어떤 명령에 대한 지연시간입니다. 이러한 지연시간을 백분위수로 나타낸 그래프입니다. SEQ 작업은 특성상 작업이 동시에 완전히 종료되는 것이 중요하다고 판단했기에, RND 성능, 그 중에서도 QD1에 대해서만 비교합니다.</p><p>이 그래프들은 지연시간을 나타내지만 실질적인 IOPS는 나타내지 않습니다. 타당한 비교를 하기 위해서는 지연시간만이 아닌 별도의 성능지표가 필요합니다. 따라서 평균 IOPS를 범례에 표시해 여러 SSD를 비교합니다.</p><p><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">다른 파트에서는 눈에 익숙한 MiB/s값을 고집했지만, 여기서는 IOPS단위를 고집한 이유는 다음과 같습니다. MiB/s 단위로 표기하면 변화가 작아서 덜 직관적이라는 것이 첫 번째이며, 이 부분의 그래프와 다음 부분의 그래프의 워크로드는 전부 4kiB 사이즈란 것이 두 번째입니다.</span></p><h3 id="mcetoc_1iuejmtca47i">Tail Latency</h3><figure class="post__image"><img loading="lazy" src="https://freshflash4096.github.io/media/posts/31/Figure_1-19.png" alt="" width="1000" height="600"><figcaption>RND Read - Tail Latency</figcaption></figure><figure class="post__image"><img loading="lazy" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);" src="https://freshflash4096.github.io/media/posts/31/Figure_1-21.png" alt="" width="1000" height="600"><figcaption>RND RW70 - Tail Latency</figcaption></figure><figure class="post__image"><img loading="lazy" style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);" src="https://freshflash4096.github.io/media/posts/31/Figure_1-22.png" alt="" width="1000" height="600"></figure><table style="border-collapse: collapse; width: 100%; height: 291.375px;" border="1"><tbody><tr style="height: 48.5625px;"><td style="width: 24.9644%; height: 48.5625px;">Percentile</td><td style="width: 24.9644%; height: 48.5625px;">RND Read</td><td style="width: 24.9644%; height: 48.5625px;">RND Read 70%</td><td style="width: 24.9644%; height: 48.5625px;">RND Write</td></tr><tr style="height: 48.5625px;"><td style="width: 24.9644%; height: 48.5625px;">90%</td><td style="width: 24.9644%; height: 48.5625px;">10.98 <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">µs</span></td><td style="width: 24.9644%; height: 48.5625px;">22.67 µs</td><td style="width: 24.9644%; height: 48.5625px;">22.97 µs</td></tr><tr style="height: 48.5625px;"><td style="width: 24.9644%; height: 48.5625px;">99%</td><td style="width: 24.9644%; height: 48.5625px;">20.45 <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">µs</span></td><td style="width: 24.9644%; height: 48.5625px;">23.72 µs</td><td style="width: 24.9644%; height: 48.5625px;">36.10 µs</td></tr><tr style="height: 48.5625px;"><td style="width: 24.9644%; height: 48.5625px;">99.9%</td><td style="width: 24.9644%; height: 48.5625px;">38.75 <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">µs</span></td><td style="width: 24.9644%; height: 48.5625px;">43.80 µs</td><td style="width: 24.9644%; height: 48.5625px;">48.57 µs</td></tr><tr style="height: 48.5625px;"><td style="width: 24.9644%; height: 48.5625px;">99.99%</td><td style="width: 24.9644%; height: 48.5625px;">43.62 <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">µs</span></td><td style="width: 24.9644%; height: 48.5625px;">50.15 µs</td><td style="width: 24.9644%; height: 48.5625px;">52.31 µs</td></tr><tr style="height: 48.5625px;"><td style="width: 24.9644%; height: 48.5625px;">99.999%</td><td style="width: 24.9644%; height: 48.5625px;">52.27 <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">µs</span></td><td style="width: 24.9644%; height: 48.5625px;">57.57 µs</td><td style="width: 24.9644%; height: 48.5625px;">53.83 µs</td></tr></tbody></table><p>꼬리 지연시간입니다. eSSD의 스펙시트에서는 QoS 항목에 이러한 정보가 명시되어 있습니다.</p><p>사실상 Percentile Latency 그래프에서 90% 이상 구간을 확대시키고 로그스케일을 적용한 그래프입니다. 총 IO에서 가장 늘어진 지연시간들의 집합이며, 사용자 경험에 직접 영향을 줄 수 있는 영역입니다.</p><p>Percentile Latency, Tail Latency에서 이러한 X축과 Y축을 채용한 것은 Y=X에 가까운 그래프면 조금은 더 파악하기 쉽다는 발상에서 착안했습니다. one-nine Latency부터 five-nine Latency에 대한 상세한 값은 별도의 표로 나타냅니다.</p><hr><h2 id="mcetoc_1iueju0sm49b">How about eSSD Benchmarking?</h2><p>eSSD 벤치마크는 ezFIO를 통해 수행되며, eSSD 중에서도 SCM급이나 WI SSD는 추가로 WSAT(Write Saturation) Test를 수행합니다. </p><p>다만, 최신 초고용량 SSD에서는 IU(Indirection Unit)의 크기가 4k가 아닌 경우가 있는데, 이러한 경우에는 드라이브의 IU보다 작은 크기의 쓰기 벤치마크는 진행하지 않습니다. </p><table style="border-collapse: collapse; width: 100%;" border="1"><tbody><tr><td style="width: 24.9644%;"> </td><td style="width: 24.9644%;">cSSD</td><td style="width: 24.9644%;">eSSD - RI / Mix</td><td style="width: 24.9644%;">eSSD - WI</td></tr><tr><td style="width: 24.9644%;">cSSD Benchmark</td><td style="width: 24.9644%;">O</td><td style="width: 24.9644%;">O</td><td style="width: 24.9644%;">O</td></tr><tr><td style="width: 24.9644%;">eSSD Benchmark</td><td style="width: 24.9644%;">X</td><td style="width: 24.9644%;">O</td><td style="width: 24.9644%;">O</td></tr><tr><td style="width: 24.9644%;">WSAT Test</td><td style="width: 24.9644%;">X</td><td style="width: 24.9644%;">X</td><td style="width: 24.9644%;">O</td></tr></tbody></table><p>위 표를 보면 각 SSD에 대해 적용할 벤치마크가 이해가 쉬울 것입니다. 몇 가지 궁금할 사항에 대해 설명하겠습니다.</p><p>eSSD에 대해 cSSD 벤치마크를 수행하는 이유는 일반 소비자들도 드물지만 중고시장을 통해 eSSD를 구매하는 경우가 있기 때문입니다. 일반 소비자의 워크로드에 최적화되진 않았지만 저를 포함한 사용사례가 분명히 존재하며, 다른 리뷰에선 찾아보기 힘들기 때문에 제 궁금사항을 풀고자 진행합니다.</p><p>그렇다면 cSSD에 대해 eSSD 벤치마크를 수행하지 않는 이유는? cSSD에서는 eSSD 벤치마크의 기본이 되는 Steady State에 진입하는 것부터가 힘든 사례가 일부 존재합니다. 애초부터 시작할 수도 없는 SSD가 있다는 말이죠.</p><p>물론 가능한 SSD들도 상당수가 존재하지만, 일반적으로 도입하기엔 시간이 상당히 오래 걸리게되어 타협할 수 밖에 없는 선택지였습니다. 이러한 이유로 cSSD 벤치마크에서도 계획보다 제외된 테스트가 상당수 존재합니다.</p><hr><h2 id="mcetoc_1iuek3eau49h">Benchmark Flow</h2><p>방법을 정리하며 흐름을 살펴보겠습니다. 각 테스트 집합은 완전히 개별로 진행됩니다. </p><h3>WSAT Test</h3><p>FOB상태에서 진행되며, User Capacity의 4배 용량만큼 4kiB RND 쓰기를 가하는 것과 512B SEQ 쓰기를 가하는 것으로 진행됩니다. 후자는 RW 비율이 50:50로 진행됩니다.</p><h3>eSSD Test</h3><p>앞서 말한대로 SNIA의 SSS-PTS에 입각해 Purge를 진행한 후, WIPC(Workload Independent Pre-Conditioning)으로 128kiB SEQ 쓰기를 전체 용량에 대해 2번 진행하고 WDPC(Workload Dependent Pre-Conditioning)으로 벤치마크할 워크로드에 대해서 Steady State에 도달할 때까지 부하를 가합니다.</p><p>Steady State에 도달하면 측정값을 수집하는데, 이러한 일련의 과정에는 휴식이 부여되지 않습니다.</p><h3>cSSD Test</h3><p>종류가 많으므로 단계를 나열하겠습니다.</p><ol><li>Purge</li><li>FOB상태에서 CDM Default, NVMe Profile의 순서로 벤치마크 수행</li><li>cSSD Pre-Conditioning 진행 이후, CDM, 3DMark, SPECworkstation 벤치마크 수행</li><li>Purge</li><li>Fill Drive 벤치마크 수행</li><li>cSSD Pre-Conditioning 중 RND와 Trim 단계 진행 후, 앞에서 말한 벤치마크를 차례대로 수행</li></ol><p>Fill Drive 벤치마크 자체가 cSSD Pre-Conditioning에서 SEQ영역을 작성하는 것과 같으므로 두 번째 Pre-Conditioning에선 SEQ 단계를 제외합니다.</p><p>또한, cSSD Pre-Conditioning은 eSSD와 다르게 유휴시간이 충분히 주어집니다. 뿐만 아니라, 성능 측정 단계에서도 충분한 유휴시간이 주어지는 것이 중요한 부분입니다.</p><hr><h2 id="mcetoc_1iuek3eau49h">Test Platform</h2><p>벤치마크 종류를 살펴보았으니 이제 수행되는 플랫폼에 대해 살펴보겠습니다. 금전의 영향을 많이 받아 타협을 거듭했습니다.</p><h3 id="mcetoc_1iuek40fa49k">Hardware</h3><table style="border-collapse: collapse; width: 100%;" border="1"><tbody><tr><td style="width: 17.2611%;"><strong>CPU</strong></td><td style="width: 64.4789%;">AMD Ryzen 5 9600X</td><td style="width: 18.26%;">PBO Disable</td></tr><tr><td style="width: 17.2611%;"><strong>MainBoard</strong></td><td style="width: 64.4789%;">ASRock B650M PG Riptide WiFi White</td><td style="width: 18.26%;">BIOS 3.30</td></tr><tr><td style="width: 17.2611%;"><strong>RAM</strong></td><td style="width: 64.4789%;">TeamGroup T-create DDR5-5600 CL46 Classic 32GB *2</td><td style="width: 18.26%;"> </td></tr><tr><td style="width: 17.2611%;"><strong>Boot SSD</strong></td><td style="width: 64.4789%;">Intel Optane SSD 800P 118GB</td><td style="width: 18.26%;"> </td></tr><tr><td style="width: 17.2611%;"><strong>PSU</strong></td><td style="width: 64.4789%;">Corsair SF750 ATX3.1</td><td style="width: 18.26%;"> </td></tr><tr><td style="width: 17.2611%;"><strong>Case</strong></td><td style="width: 64.4789%;">SilverStone RM23-502-MINI</td><td style="width: 18.26%;"> </td></tr><tr><td style="width: 17.2611%;"><strong>Cooler</strong></td><td style="width: 64.4789%;">Noctua NH-L9a-AM5 chromax.black</td><td style="width: 18.26%;">Full Speed</td></tr><tr><td style="width: 17.2611%;"><strong>Cooler</strong></td><td style="width: 64.4789%;">Noctua NF-A8 PWM</td><td style="width: 18.26%;">Full Speed</td></tr><tr><td style="width: 17.2611%;"><strong>Ex</strong></td><td style="width: 64.4789%;">Sipeed NanoKVM PCIe</td><td style="width: 18.26%;"> </td></tr><tr><td style="width: 17.2611%;"><strong>SW_Win</strong></td><td style="width: 64.4789%;">Windows 11 Pro (24H2)</td><td style="width: 18.26%;"> </td></tr><tr><td style="width: 17.2611%;"><strong>SW_Linux</strong></td><td style="width: 64.4789%;">Rocky Linux 10 Minimal (6.12.0-55.12.1.el10_0)</td><td style="width: 18.26%;">FIO 3.40</td></tr></tbody></table><p>DUT(Device Under Test)가 될 SSD는 CPU레인에 직결하며, 최대 2-connector Topology까지 허용합니다. </p><p>다시 말해, M.2 NVMe SSD는 CPU와 가장 가까운 PCIe 5.0 x4를 지원하는 M.2 슬롯에 장착하며, AIC타입과 2.5" NVMe SSD는 CPU와 가장 가까운 PCIe x16 슬롯에 장착하게 됩니다. 물론, 후자는 어댑터의 사용이 필수불가결하며, 여기엔 <span style="text-decoration: underline;"><em>UMC-PTU-2</em></span>라는 어댑터를 사용합니다.</p><p>2.5" SATA SSD는 PROM21(B650 Chipset)에 내장된 SATA 컨트롤러에 의지해, 온보드 SATA 포트에 장착합니다.</p><p>기본적으로 이 시스템은 제 랩이 가동되는 랙에 마운트되어 있기에 원격으로 설정할 필요가 있습니다. 따라서, <em><span style="text-decoration: underline;">NanoKVM</span></em>을 사용해 OOBM(Out-of-band Management)기능을 더합니다.</p><p>기본적으로 DUT는 Spot Cooling을 통해 Thermal Throttling을 방지합니다.</p><h3 id="mcetoc_1iuek4g3749n">Software</h3><p>Windows는 전원옵션에서 고성능을 설정하고 상세값을 그에 맞춰주었으며 Indexing Service, Scheduled Defragmentation, System Protection, Windows Defender, Windows Updates를 비활성화했습니다. 혹시 모를 백그라운드 작업을 대비해 네트워크는 연결하지 않고 벤치마크를 진행합니다.</p><pre class="language-batch"><code>start /wait Rundll32.exe advapi32.dll/ProcessIdleTasks</code></pre><p>그에 더해 HWiNFO, 작업관리자, 벤치마크 도구를 실행시킨 뒤, 위 명령어를 입력하고 15분 뒤를 IDLE상태로 정의해 벤치마크를 진행했습니다.</p><p>Windows는 Linux와 달리 NTFS의 기본값으로 포맷한 뒤에 벤치마크를 진행합니다. 이것이 Pre-Conditioning 단계를 구분해야했던 이유이기도 하고요.</p><p>Rocky Linux는 Minimal 옵션으로 설치 이후에 필요한 패키지만 추가하였으며, 드라이버는 Windows, Linux 둘 다 Inbox Driver를 사용했습니다. </p><p>Latency는 IO 조각이 제출된 시점에서 완료될 때까지의 시간을 측정한 값을 사용합니다.</p><h3 id="mcetoc_1iujejkk8bn">Future Improvements</h3><p>자본은 유한합니다. 금전 뿐만 아니라 시간도 하나의 자본이죠.</p><p>최초 계획과 현재 방법에는 약간의 차이가 있는데, 특히 cSSD 벤치마크에서 가장 차이가 벌어집니다. 유휴시간에 대한 캐시 복구, Steady State 성능, OCP BootBench등도 시간 상의 문제로 누락했습니다. 이는 추후에도 일반적으로 도입할 생각은 없으며, 몇몇 특이한 사항이 있는 SSD에 한정해 별도로 추가 벤치마크를 진행할 가능성이 있습니다.</p><p>SSD에서 중요한 지표는 성능 뿐만이 아니라 신뢰성, 전력효율, 발열 등이 있습니다. 신뢰성은 개인의 입장에서 굉장히 평가하기 어려운 지표이므로 진작 포기했지만 전력효율과 발열에 대해선 생각이 조금 있습니다.</p><p>전력은 개인적으로 Quarch Technology사의 제품을 고민 중인데, 가격이 상당해 마음에만 담아두고 있는 상태입니다. ElmorLabs에도 PMD라는 전력측정 장비가 있긴하지만, cSSD의 유휴 전력을 제대로 측정할 수 있는지 약간 의문이 들어 보류했습니다.</p><p>온도는 쉽게 측정하려면 S.M.A.R.T.를 쿼리하며 로그를 남기는 방식으로 아주 쉬울 수 있습니다. 하지만 제 환경에서는 여러 의미로 변인이 통제되지 않는데, 우선 테스트 시스템 자체가 별도의 시스템이 추가로 들어있는 랙 캐비닛에 수납되어 있기에 온도 통제에서 자유롭지 못합니다. 또한, SSD에 내장된 온도센서도 조금씩 차이가 있기에 외부 온도계를 사용해야 정확한 비교가 가능하다고 판단했습니다.</p><p>추가로 HW측면에서는 이후 쿨링이나 편의성을 고려해 2U 케이스에서 3U 케이스로 변경할 생각이며, 2.5" NVMe SSD의 테스트에는 최소한 ReDriver가 사용된 어댑터를 사용하고자 합니다. 추가로 메인보드 또한 온보드 BMC가구현된 보드를 생각하고 있습니다.</p><p>부팅용 SSD는 PM981a 256GB로 2개를 마련해놓은 상태이며, 각자 OS를 설치해 바꿔가며 벤치마크를 진행할 예정입니다.</p><h2 id="mcetoc_1iuel76km4a0">Closing</h2><p>여기까지 오는데 많은 시간이 걸린 것 같습니다. 다만, 예시를 905P로 들게된 점은 약간 아쉽기도 합니다. 개인적인 이유로 제 손에서 떠날 물건이라 빠르게 진행했네요.</p><p>우선, 지인들이 빌려준 cSSD들이 상당 수 있습니다. 얼른 벤치마크를 진행하고 돌려드리려 합니다. eSSD 밖에 없어서 첫 벤치마크 대상으로 고민하던 제게 희망을 제시한 지인분들께 감사를 전합니다.</p><figure class="post__image align-center"><img loading="lazy" src="https://freshflash4096.github.io/media/posts/31/seukeurinsyas-2025-06-24-ojeon-12.11.30.png" alt="" width="309" height="102"></figure><p>코드는 비공개 레포에서 개발했으며, 구성비율은 위와 같습니다. 앞으로 개선사항은 있더라도 코드 자체를 공개할 생각은 없습니다.</p><p>모르는 부분이 많고 아는 것도 없지만 직접 벤치마크를 하려는 이유는 제가 궁금한 점을 중심으로 벤치마크를 진행한 곳이 없었기 때문입니다. 저와 비슷하게 궁금한 것이 있는 분들에게 제 벤치마크가 도움이 되었으면 합니다.</p><p>컴퓨터에 관심을 가지게 된지 6년이 되어갑니다. 6년 뒤에도 벤치마크를 하고 있을지는 모르겠지만, 이렇게 공개적으로 하며 저도 성장해갔으면 좋겠네요.</p><p>긴 글 읽어주셔서 감사합니다.</p><hr><h2 id="mcetoc_1iuel7q734a3">Reference</h2><pre>제가 고민하며 참고한 자료들의 극히 일부를 순서없이 랜덤으로 정렬한 것 입니다. 이외에도 FMS의 발표자료, 여러 SSD의 데이터시트를 참고했습니다. 문서의 원본을 찾게된다면 이후에도 추가될 수 있습니다.</pre><ul><li>OCP Datacenter NVMe SSD Specification</li><li>ezFIO User Guide</li><li>OCP Hyperscale NVMe Boot SSD Specification</li><li>JEDEC STANDARD Solid-State Drive (SSD) Requirements and Endurance Test Method (JESD218)</li><li>JEDEC STANDARD Solid-State Drive (SSD) Endurance Workloads (JESD219)</li><li>OCP NVMe Cloud SSD Specification</li><li>Intel Performance Benchmarking for PCIe* and NVMe* Enterprise Solid-State Drives</li><li>Solidigm PC Storage Performance in the Real World</li><li>Micron SSD Performance States</li><li>Intel Partition Alignment of Intel SSDs for Achieving Maximum Performance and Endurance</li><li>Understanding SSD Performance: Using the SSS PTS to Evaluate and Compose SSD Performance</li><li>Understanding SSD Performance Using the SNIA SSS PTS Performance Test Specification</li><li>SNIA Solid State Storage Performance Test Secificatoin</li><li>fio - Flexible I/O tester rev. 3.38</li><li>Understanding datacentre workload quality of service</li><li>JEDEC MasterTrace_128GB-SSD</li><li>JEDEC TestTrace_64GB-128GB-SSD</li><li>Intel Optane Solid State Drives for Client Evaluation Guide</li><li>Intel Optane Solid State Drive DC P4800X (Linux) Performance Evaluation Guide</li><li>NVM Express Base Specification</li><li>Intel Optane Solid State Drive DC P4800X Series (Windows) Performance Evaluation Guide</li><li>Intel Optane Solid State Drive DC P4800X (VMware) Performance Evaluation Guide</li></ul><p> </p></div><footer class="content__footer"><div class="content__last-updated">This article was updated on <time datetime="2025-06-26T22:16">6월 26, 2025</time></div></footer></div></article></main><div class="right-bar"><div class="right-bar__inner"><div class="sidebar"><section class="box tags"><h3 class="box__title">Recommended Topics</h3><ul class="tags__list"><li class="tags__item"><a href="https://freshflash4096.github.io/tags/archive/" class="btn btn--gray">Archive <sup>(11)</sup></a></li><li class="tags__item"><a href="https://freshflash4096.github.io/tags/benchmark/" class="btn btn--gray">Benchmark <sup>(1)</sup></a></li><li class="tags__item"><a href="https://freshflash4096.github.io/tags/homelab/" class="btn btn--gray">Homelab <sup>(6)</sup></a></li></ul></section><div class="box follow"><a href="https://www.instagram.com/freshflash4096/" class="tltp tltp--top" aria-label="Instagram"><svg><use xlink:href="https://freshflash4096.github.io/assets/svg/svg-map.svg#instagram"/></svg> <span>Instagram</span> </a><a href="https://www.youtube.com/@FreshFlash4096" class="tltp tltp--top" aria-label="Youtube"><svg><use xlink:href="https://freshflash4096.github.io/assets/svg/svg-map.svg#youtube"/></svg> <span>Youtube</span></a></div><div class="box copyright">Huie / @FreshFlash4096</div></div></div></div></div><script defer="defer" src="https://freshflash4096.github.io/assets/js/scripts.min.js?v=b2d91bcadbf5db401b76eb5bb3092eb7"></script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>